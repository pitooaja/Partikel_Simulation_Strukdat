// em_field_sim_sfml3.cpp
// SFML 3.x compatible
#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <sstream>

// ---------- SFML3 rect helpers ----------
inline bool rectContains(const sf::Rect<float>& r, const sf::Vector2f& p) {
    return p.x >= r.position.x && p.x <= r.position.x + r.size.x
        && p.y >= r.position.y && p.y <= r.position.y + r.size.y;
}
inline bool rectIntersects(const sf::Rect<float>& a, const sf::Rect<float>& b) {
    return !(a.position.x + a.size.x < b.position.x ||
             b.position.x + b.size.x < a.position.x ||
             a.position.y + a.size.y < b.position.y ||
             b.position.y + b.size.y < a.position.y);
}

// ---------------- Particle ----------------
struct Particle {
    sf::Vector2f pos;
    sf::Vector2f vel;
    float radius;
    float mass;
    float charge; // negative, positive, or 0
    sf::Color color;
    float flashTimer = 0.f;

    Particle(const sf::Vector2f& p, const sf::Vector2f& v, float r, float m, float q)
    : pos(p), vel(v), radius(r), mass(m), charge(q) {
        if (q > 0.0f) color = sf::Color::Red;
        else if (q < 0.0f) color = sf::Color::Blue;
        else color = sf::Color(180,180,180);
    }

    void applyForce(const sf::Vector2f& f, float dt) {
        // a = F/m
        sf::Vector2f a = { f.x / mass, f.y / mass };
        vel += a * dt;
    }

    void update(float dt, const sf::RenderWindow& win) {
        pos += vel * dt;

        // bounds & small damping on walls
        float W = static_cast<float>(win.getSize().x);
        float H = static_cast<float>(win.getSize().y);
        if (pos.x - radius < 0.f)  { pos.x = radius; vel.x *= -0.3f; }
        if (pos.x + radius > W)    { pos.x = W - radius; vel.x *= -0.3f; }
        if (pos.y - radius < 0.f)  { pos.y = radius; vel.y *= -0.3f; }
        if (pos.y + radius > H)    { pos.y = H - radius; vel.y *= -0.25f; }

        if (flashTimer > 0.f) flashTimer -= dt;
    }

    void draw(sf::RenderWindow& win) const {
        sf::CircleShape c(radius);
        c.setOrigin({radius, radius});
        c.setPosition(pos);
        if (flashTimer > 0.f) {
            // brighter flash color
            c.setFillColor(sf::Color::White);
        } else {
            c.setFillColor(color);
        }
        win.draw(c);
    }
};

// ---------------- Quadtree ----------------
struct Quadtree {
    sf::Rect<float> boundary;
    int capacity;
    bool divided = false;
    std::vector<Particle*> points;
    std::unique_ptr<Quadtree> NE, NW, SE, SW;

    Quadtree(const sf::Rect<float>& area, int cap) : boundary(area), capacity(cap) {}

    bool insert(Particle* p) {
        if (!rectContains(boundary, p->pos)) return false;
        if (static_cast<int>(points.size()) < capacity) {
            points.push_back(p);
            return true;
        }
        if (!divided) subdivide();
        return NE->insert(p) || NW->insert(p) || SE->insert(p) || SW->insert(p);
    }

    void subdivide() {
        float x = boundary.position.x, y = boundary.position.y;
        float w = boundary.size.x / 2.f, h = boundary.size.y / 2.f;
        NE = std::make_unique<Quadtree>(sf::Rect<float>({x + w, y}, {w, h}), capacity);
        NW = std::make_unique<Quadtree>(sf::Rect<float>({x,     y}, {w, h}), capacity);
        SE = std::make_unique<Quadtree>(sf::Rect<float>({x + w, y + h}, {w, h}), capacity);
        SW = std::make_unique<Quadtree>(sf::Rect<float>({x,     y + h}, {w, h}), capacity);
        divided = true;
    }

    void query(const sf::Rect<float>& range, std::vector<Particle*>& found) const {
        if (!rectIntersects(boundary, range)) return;
        for (auto p : points) if (rectContains(range, p->pos)) found.push_back(p);
        if (!divided) return;
        NE->query(range, found);
        NW->query(range, found);
        SE->query(range, found);
        SW->query(range, found);
    }

    void drawBoundaries(sf::RenderWindow& win) const {
        sf::RectangleShape rect;
        rect.setPosition(boundary.position);
        rect.setSize(boundary.size);
        rect.setFillColor(sf::Color::Transparent);
        rect.setOutlineThickness(1.f);
        rect.setOutlineColor(sf::Color(40,40,60));
        win.draw(rect);
        if (!divided) return;
        NE->drawBoundaries(win);
        NW->drawBoundaries(win);
        SE->drawBoundaries(win);
        SW->drawBoundaries(win);
    }
};

// ---------------- Physics & Collisions ----------------
inline bool overlap(const Particle& a, const Particle& b) {
    float dx = b.pos.x - a.pos.x;
    float dy = b.pos.y - a.pos.y;
    float dist2 = dx*dx + dy*dy;
    float rsum = a.radius + b.radius;
    return dist2 < (rsum * rsum);
}

void resolveOverlap(Particle& a, Particle& b) {
    sf::Vector2f d = b.pos - a.pos;
    float dist = std::sqrt(d.x*d.x + d.y*d.y);
    if (dist == 0.f) { d = {0.001f, 0.001f}; dist = std::sqrt(d.x*d.x + d.y*d.y); }
    float rsum = a.radius + b.radius;
    float overlap = rsum - dist;
    if (overlap <= 0.f) return;
    sf::Vector2f n = {d.x / dist, d.y / dist};
    sf::Vector2f corr = n * (overlap * 0.5f + 0.001f);
    a.pos -= corr;
    b.pos += corr;
    // exchange momentum roughly (simple)
    sf::Vector2f va = a.vel, vb = b.vel;
    a.vel = va * 0.6f + vb * 0.4f;
    b.vel = vb * 0.6f + va * 0.4f;
    a.flashTimer = b.flashTimer = 0.12f;
}

// Coulomb & Lorentz
// Coulomb: F = k * q1*q2 / (r^2 + eps) * dir
// Lorentz (2D, Bz): F = q * Bz * (-vy, vx)
void applyElectromagneticForcesBrute(std::vector<Particle>& particles,
                                      float k_const, float cutoff, float softening,
                                      float Bz, float dt) {
    int n = static_cast<int>(particles.size());
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            Particle &a = particles[i], &b = particles[j];
            sf::Vector2f d = b.pos - a.pos;
            float dist2 = d.x*d.x + d.y*d.y;
            float dist = std::sqrt(dist2 + 1e-12f);
            if (dist > cutoff) continue;

            // Coulomb
            float qprod = a.charge * b.charge;
            if (qprod != 0.f) {
                float forceMag = k_const * qprod / (dist2 + softening);
                sf::Vector2f dir = {d.x / dist, d.y / dist};
                sf::Vector2f F = dir * forceMag;
                a.applyForce(F * -1.f, dt);
                b.applyForce(F, dt);
            }

            // collision handling (positional)
            if (dist < a.radius + b.radius) resolveOverlap(a, b);
        }
    }

    // Lorentz per particle
    if (Bz != 0.f) {
        for (auto &p : particles) {
            // F = q * (v x B) ; for B = (0,0,Bz) -> ( -q*Bz*vy, q*Bz*vx )
            sf::Vector2f F = { -p.charge * Bz * p.vel.y, p.charge * Bz * p.vel.x };
            p.applyForce(F, dt);
        }
    }
}

void applyElectromagneticForcesQuadtree(std::vector<Particle>& particles,
                                        const Quadtree& qt,
                                        float k_const, float cutoff, float softening,
                                        float Bz, float dt) {
    // for each particle query nearby neighbors
    for (auto &p : particles) {
        sf::Rect<float> range({p.pos.x - cutoff, p.pos.y - cutoff}, {cutoff*2.f, cutoff*2.f});
        std::vector<Particle*> near;
        qt.query(range, near);
        for (auto *other : near) {
            if (&p == other) continue;
            sf::Vector2f d = other->pos - p.pos;
            float dist2 = d.x*d.x + d.y*d.y;
            float dist = std::sqrt(dist2 + 1e-12f);
            if (dist > cutoff) continue;

            float qprod = p.charge * other->charge;
            if (qprod != 0.f) {
                float forceMag = k_const * qprod / (dist2 + softening);
                sf::Vector2f dir = {d.x / dist, d.y / dist};
                sf::Vector2f F = dir * forceMag;
                p.applyForce(F, dt);
                other->applyForce(F * -1.f, dt);
            }

            if (dist < p.radius + other->radius) resolveOverlap(p, *other);
        }
    }

    if (Bz != 0.f) {
        for (auto &p : particles) {
            sf::Vector2f F = { -p.charge * Bz * p.vel.y, p.charge * Bz * p.vel.x };
            p.applyForce(F, dt);
        }
    }
}

// ---------------- HUD (simple text) ---------------- 
struct HUD {
    sf::Font font;
    bool ok=false;
    HUD() { 
        // SFML 3 font loading - disable for now if font file not available
        ok = false; // Set to true and load font if you have arial.ttf
    }
    void drawText(sf::RenderWindow& win, const std::string& s, float x, float y, unsigned size=14) {
        // Text rendering disabled - program will work without text
        (void)win; (void)s; (void)x; (void)y; (void)size; // Suppress warnings
    }
};

// ---------------- MAIN ----------------
int main() {
    std::srand(static_cast<unsigned>(std::time(nullptr)));
    sf::RenderWindow window(sf::VideoMode({1000u, 700u}), "EM Particle Simulation â€” Coulomb & Lorentz (Brute vs Quadtree)");
    window.setFramerateLimit(60);

    std::vector<Particle> particles;
    particles.reserve(1000);

    // simulation params
    float k_const = 20000.f;      // Coulomb constant (tune)
    float cutoff = 220.f;         // max distance to apply Coulomb (perf)
    float softening = 100.f;      // to avoid singularity
    float Bz = 0.f;               // magnetic field strength (z)
    float particleRadius = 5.f;

    // quadtree params
    const int qtCapacity = 6;
    enum Mode { BRUTE=0, QUAD=1 };
    Mode mode = QUAD;

    bool drawField = false; // visualize field lines? (simple)
    HUD hud;

    // initial cluster
    for (int i = 0; i < 200; ++i) {
        float x = 300.f + std::rand()%300;
        float y = 100.f + std::rand()%200;
        float vx = -20 + std::rand()%40;
        float vy = -10 + std::rand()%20;
        float charge = (std::rand()%3==0 ? 1.0f : (std::rand()%5==0 ? -1.0f : 0.0f));
        particles.emplace_back(sf::Vector2f{x,y}, sf::Vector2f{vx, vy}, particleRadius, 1.f, charge);
    }

    // timing
    sf::Clock clock;
    float fpsTimer = 0.f; int frames=0; int fps=0;

    while (window.isOpen()) {
        // events
        while (auto ev = window.pollEvent()) {
            if (auto* closed = ev->getIf<sf::Event::Closed>()) window.close();
            else if (auto* key = ev->getIf<sf::Event::KeyPressed>()) {
                if (key->code == sf::Keyboard::Key::Num1) mode = BRUTE;
                if (key->code == sf::Keyboard::Key::Num2) mode = QUAD;
                if (key->code == sf::Keyboard::Key::B) Bz = (Bz == 0.f ? 0.8f : 0.f);
                if (key->code == sf::Keyboard::Key::F) Bz += 0.1f;
                if (key->code == sf::Keyboard::Key::G) Bz -= 0.1f;
                if (key->code == sf::Keyboard::Key::V) drawField = !drawField;
                if (key->code == sf::Keyboard::Key::R) particles.clear();
                // spawn shortcuts
                if (key->code == sf::Keyboard::Key::Q) {
                    // add positive
                    sf::Vector2i mp = sf::Mouse::getPosition(window);
                    particles.emplace_back(sf::Vector2f{static_cast<float>(mp.x)+ (std::rand()%20-10), static_cast<float>(mp.y)+(std::rand()%20-10)},
                                           sf::Vector2f{(std::rand()%40)-20,(std::rand()%40)-20}, particleRadius, 1.f, +1.f);
                }
                if (key->code == sf::Keyboard::Key::W) {
                    // add negative
                    sf::Vector2i mp = sf::Mouse::getPosition(window);
                    particles.emplace_back(sf::Vector2f{static_cast<float>(mp.x)+ (std::rand()%20-10), static_cast<float>(mp.y)+(std::rand()%20-10)},
                                           sf::Vector2f{(std::rand()%40)-20,(std::rand()%40)-20}, particleRadius, 1.f, -1.f);
                }
                if (key->code == sf::Keyboard::Key::E) {
                    // neutral
                    sf::Vector2i mp = sf::Mouse::getPosition(window);
                    particles.emplace_back(sf::Vector2f{static_cast<float>(mp.x)+ (std::rand()%20-10), static_cast<float>(mp.y)+(std::rand()%20-10)},
                                           sf::Vector2f{(std::rand()%40)-20,(std::rand()%40)-20}, particleRadius, 1.f, 0.f);
                }
            } else if (auto* mouse = ev->getIf<sf::Event::MouseButtonPressed>()) {
                if (mouse->button == sf::Mouse::Button::Left) {
                    sf::Vector2i mp = sf::Mouse::getPosition(window);
                    // spawn a burst of mixed charges
                    for (int i = 0; i < 18; ++i) {
                        float jitterX = static_cast<float>(std::rand()%60 - 30);
                        float jitterY = static_cast<float>(std::rand()%60 - 30);
                        float vx = static_cast<float>(std::rand()%80 - 40);
                        float vy = static_cast<float>(std::rand()%80 - 40);
                        float q = (std::rand()%4 == 0) ? 1.f : ((std::rand()%6==0)? -1.f : 0.f);
                        particles.emplace_back(sf::Vector2f{static_cast<float>(mp.x)+jitterX, static_cast<float>(mp.y)+jitterY},
                                               sf::Vector2f{vx, vy}, particleRadius, 1.f, q);
                    }
                }
            }
        }

        float dt = clock.restart().asSeconds();
        if (dt > 0.033f) dt = 0.033f; // clamp

        // reset colors / update positions
        for (auto &p : particles) {
            // color based on charge (keep darker flash when colliding)
            if (p.flashTimer <= 0.f) {
                if (p.charge > 0.f) p.color = sf::Color(220, 100, 100);
                else if (p.charge < 0.f) p.color = sf::Color(100, 120, 220);
                else p.color = sf::Color(190, 190, 190);
            }
            p.update(dt, window);
        }

        // build quadtree
        sf::Rect<float> world({0.f, 0.f}, {static_cast<float>(window.getSize().x), static_cast<float>(window.getSize().y)});
        Quadtree qt(world, qtCapacity);
        if (mode == QUAD) {
            for (auto &p : particles) qt.insert(&p);
            applyElectromagneticForcesQuadtree(particles, qt, k_const, cutoff, softening, Bz, dt);
        } else {
            applyElectromagneticForcesBrute(particles, k_const, cutoff, softening, Bz, dt);
        }

        // simple damping to avoid runaway velocities
        for (auto &p : particles) p.vel *= 0.9995f;

        // HUD and FPS
        fpsTimer += dt; frames++;
        if (fpsTimer >= 0.5f) { fps = static_cast<int>(frames / fpsTimer); fpsTimer = 0.f; frames = 0; }

        // draw
        window.clear(sf::Color(10, 12, 18));
        // optionally draw field visualization (very simple arrows on grid)
        if (drawField) {
            const int GRID = 25;
            for (int gy = GRID/2; gy < static_cast<int>(window.getSize().y); gy += GRID) {
                for (int gx = GRID/2; gx < static_cast<int>(window.getSize().x); gx += GRID) {
                    sf::Vector2f pos((float)gx, (float)gy);
                    // compute simple local field vector (sum contributions from charges, truncated)
                    sf::Vector2f E = {0.f, 0.f};
                    for (const auto &p : particles) {
                        sf::Vector2f d = p.pos - pos;
                        float d2 = d.x*d.x + d.y*d.y + 1e-2f;
                        if (d2 > 2500.f) continue;
                        float inv = p.charge / d2;
                        E.x += d.x * inv;
                        E.y += d.y * inv;
                    }
                    // draw the small arrow
                    sf::Vector2f endPos = {pos.x + E.x * 6.f, pos.y + E.y * 6.f};
                    sf::Vertex line[2];
                    line[0].position = sf::Vector2f(pos.x, pos.y);
                    line[0].color = sf::Color(80,80,100);
                    line[1].position = sf::Vector2f(endPos.x, endPos.y);
                    line[1].color = sf::Color(80,80,100);
                    window.draw(line, 2, sf::PrimitiveType::Lines);
                }
            }
        }

        // particles
        for (auto &p : particles) p.draw(window);

        // draw quadtree boundaries if active and in quadtree mode
        if (mode == QUAD) qt.drawBoundaries(window);

        // HUD text
        std::ostringstream ss;
        ss << "Mode: " << (mode==BRUTE ? "Brute Force [1]" : "Quadtree [2]")
           << "   Particles: " << particles.size()
           << "   Bz: " << std::round(Bz*100.f)/100.f
           << "   k: " << static_cast<int>(k_const)
           << "   FPS: " << fps
           << "   FieldVis [V]: " << (drawField ? "ON" : "OFF")
           << "   Spawn: Left Click  (Q/W/E add single)";
        hud.drawText(window, ss.str(), 8.f, 6.f, 14);

        window.display();
    }

    return 0;
}